# Generated by Django 4.2.26 on 2025-11-28 15:00

from django.db import migrations
import logging

logger = logging.getLogger(__name__)


def apply_solo_victories_to_existing_games(apps, schema_editor):
    from victory.utils import check_for_solo_winner

    Game = apps.get_model("game", "Game")
    Phase = apps.get_model("phase", "Phase")
    Victory = apps.get_model("victory", "Victory")

    games = Game.objects.filter(sandbox=False).prefetch_related(
        "members__nation",
        "phases",
        "variant"
    )

    total_games = games.count()
    logger.info(f"Processing {total_games} non-sandbox games for solo victory detection")

    games_updated = 0
    phases_deleted = 0
    victories_created = 0

    for game_idx, game in enumerate(games, 1):
        if game_idx % 100 == 0:
            logger.info(f"Processing game {game_idx}/{total_games}")

        if hasattr(game, 'victory'):
            continue

        phases = list(game.phases.order_by('ordinal'))

        winning_phase = None
        winner = None

        for phase in phases:
            leader = check_for_solo_winner(game, phase)

            if leader:
                winning_phase = phase
                winner = leader
                logger.info(
                    f"Solo victory detected in game {game.id} at phase {phase.ordinal} "
                    f"({phase.season} {phase.year}, {phase.type}) - Winner: {leader.nation.name}"
                )
                break

        if winning_phase:
            victory = Victory.objects.create(
                game=game,
                winning_phase=winning_phase
            )
            victory.members.add(winner)
            victories_created += 1

            game.status = "Completed"
            game.save()

            subsequent_phases = [p for p in phases if p.ordinal > winning_phase.ordinal]
            deleted_count = len(subsequent_phases)

            if subsequent_phases:
                subsequent_phase_ids = [p.id for p in subsequent_phases]
                Phase.objects.filter(id__in=subsequent_phase_ids).delete()
                phases_deleted += deleted_count
                logger.info(
                    f"Deleted {deleted_count} phases after winning phase in game {game.id}"
                )

            winning_phase.status = "Completed"
            winning_phase.scheduled_resolution = None
            winning_phase.save()

            games_updated += 1

    logger.info(
        f"Migration complete: {victories_created} victories created, "
        f"{games_updated} games updated, {phases_deleted} phases deleted"
    )


class Migration(migrations.Migration):

    dependencies = [
        ("victory", "0001_initial"),
        ("game", "0004_game_sandbox_alter_game_movement_phase_duration"),
        ("phase", "0009_revert_year_season_fix"),
        ("member", "0001_initial"),
        ("supply_center", "0004_add_hundred_supply_centers"),
        ("variant", "0005_variant_solo_victory_sc_count"),
    ]

    operations = [
        migrations.RunPython(
            apply_solo_victories_to_existing_games,
            reverse_code=migrations.RunPython.noop
        ),
    ]
