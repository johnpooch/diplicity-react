/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * OpenAPI spec version: 0.0.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import { faker } from "@faker-js/faker";

import { HttpResponse, http } from "msw";
import type { RequestHandlerOptions } from "msw";

import { customInstance } from "../axiosInstance";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

export interface Auth {
  idToken: string;
  readonly id: number;
  readonly email: string;
  readonly name: string;
  readonly accessToken: string;
  readonly refreshToken: string;
}

export interface Nation {
  name: string;
  color: string;
}

export interface ChannelMember {
  id: number;
  name: string;
  /** @nullable */
  picture: string | null;
  nation: Nation;
  readonly isCurrentUser: boolean;
}

export interface ChannelMessage {
  readonly id: number;
  /** @maxLength 1000 */
  body: string;
  readonly sender: ChannelMember;
  readonly createdAt: string;
}

export interface Channel {
  readonly id: number;
  readonly name: string;
  readonly private: boolean;
  readonly messages: readonly ChannelMessage[];
  memberIds: number[];
}

export interface DrawVoteMember {
  id: number;
  name: string;
  /** @nullable */
  picture: string | null;
  /** @nullable */
  nation: string | null;
  readonly isCurrentUser: boolean;
}

export interface DrawVote {
  readonly id: number;
  readonly member: DrawVoteMember;
  readonly included: boolean;
  /** @nullable */
  readonly accepted: boolean | null;
}

export interface DrawProposal {
  readonly id: number;
  readonly createdBy: DrawVoteMember;
  readonly status: string;
  readonly combinedScCount: number;
  readonly victoryThreshold: number;
  readonly votes: readonly DrawVote[];
  readonly phaseId: number;
  readonly createdAt: string;
  includedMemberIds: number[];
}

export interface DrawVoteUpdate {
  accepted: boolean;
}

/**
 * * `ios` - ios
 * `android` - android
 * `web` - web
 */
export type TypeEnum = (typeof TypeEnum)[keyof typeof TypeEnum];

export const TypeEnum = {
  ios: "ios",
  android: "android",
  web: "web",
} as const;

export interface FCMDevice {
  readonly id: number;
  /**
   * @maxLength 255
   * @nullable
   */
  name?: string | null;
  registrationId: string;
  /**
   * Unique device identifier
   * @maxLength 255
   * @nullable
   */
  deviceId?: string | null;
  /** Inactive devices will not be sent notifications */
  active?: boolean;
  /** @nullable */
  readonly dateCreated: string | null;
  type: TypeEnum;
}

export interface GameCloneToSandbox {
  readonly id: string;
}

/**
 * * `random` - Random
 * `ordered` - Ordered
 */
export type NationAssignmentEnum =
  (typeof NationAssignmentEnum)[keyof typeof NationAssignmentEnum];

export const NationAssignmentEnum = {
  random: "random",
  ordered: "ordered",
} as const;

/**
 * * `1 hour` - 1 hour
 * `12 hours` - 12 hours
 * `24 hours` - 24 hours
 * `48 hours` - 48 hours
 * `3 days` - 3 days
 * `4 days` - 4 days
 * `1 week` - 1 week
 * `2 weeks` - 2 weeks
 */
export type MovementPhaseDurationEnum =
  (typeof MovementPhaseDurationEnum)[keyof typeof MovementPhaseDurationEnum];

export const MovementPhaseDurationEnum = {
  "1_hour": "1 hour",
  "12_hours": "12 hours",
  "24_hours": "24 hours",
  "48_hours": "48 hours",
  "3_days": "3 days",
  "4_days": "4 days",
  "1_week": "1 week",
  "2_weeks": "2 weeks",
} as const;

/**
 * * `1 hour` - 1 hour
 * `12 hours` - 12 hours
 * `24 hours` - 24 hours
 * `48 hours` - 48 hours
 * `3 days` - 3 days
 * `4 days` - 4 days
 * `1 week` - 1 week
 * `2 weeks` - 2 weeks
 */
export type RetreatPhaseDurationEnum =
  (typeof RetreatPhaseDurationEnum)[keyof typeof RetreatPhaseDurationEnum];

export const RetreatPhaseDurationEnum = {
  "1_hour": "1 hour",
  "12_hours": "12 hours",
  "24_hours": "24 hours",
  "48_hours": "48 hours",
  "3_days": "3 days",
  "4_days": "4 days",
  "1_week": "1 week",
  "2_weeks": "2 weeks",
} as const;

export type NullEnum = (typeof NullEnum)[keyof typeof NullEnum];

export const NullEnum = {} as const;

export interface GameCreate {
  readonly id: string;
  name: string;
  variantId: string;
  nationAssignment: NationAssignmentEnum;
  movementPhaseDuration?: MovementPhaseDurationEnum;
  retreatPhaseDuration?: RetreatPhaseDurationEnum | NullEnum | null;
  private: boolean;
}

export interface GameCreateSandbox {
  readonly id: string;
  name: string;
  variantId: string;
}

export interface Member {
  readonly id: number;
  readonly name: string;
  /** @nullable */
  readonly picture: string | null;
  /** @nullable */
  readonly nation: string | null;
  readonly isCurrentUser: boolean;
  readonly eliminated: boolean;
  readonly kicked: boolean;
  readonly isGameMaster: boolean;
}

export interface Victory {
  readonly id: number;
  readonly type: string;
  readonly winningPhaseId: number;
  readonly members: readonly Member[];
}

export interface GameList {
  readonly id: string;
  readonly name: string;
  readonly status: string;
  readonly canJoin: boolean;
  readonly canLeave: boolean;
  readonly variantId: string;
  readonly phases: readonly number[];
  /** @nullable */
  readonly currentPhaseId: number | null;
  readonly private: boolean;
  /** @nullable */
  readonly movementPhaseDuration: string | null;
  /** @nullable */
  readonly retreatPhaseDuration: string | null;
  readonly nationAssignment: string;
  readonly members: readonly Member[];
  readonly victory: Victory | null;
  readonly sandbox: boolean;
}

export interface GameRetrieve {
  readonly id: string;
  readonly name: string;
  readonly status: string;
  readonly canJoin: boolean;
  readonly canLeave: boolean;
  readonly phases: readonly number[];
  /** @nullable */
  readonly currentPhaseId: number | null;
  readonly members: readonly Member[];
  readonly sandbox: boolean;
  readonly victory: Victory | null;
  readonly variantId: string;
  readonly nationAssignment: string;
  readonly phaseConfirmed: boolean;
  /** @nullable */
  readonly movementPhaseDuration: string | null;
  /** @nullable */
  readonly retreatPhaseDuration: string | null;
  readonly private: boolean;
}

export interface Province {
  id: string;
  name: string;
  type: string;
  supplyCenter: boolean;
  /** @nullable */
  parentId: string | null;
  readonly namedCoastIds: readonly string[];
}

export interface OrderResolution {
  status: string;
  by: Province | null;
}

export interface OrderOption {
  value: string;
  label: string;
}

/**
 * * `Move` - Move
 * `MoveViaConvoy` - Move via Convoy
 * `Hold` - Hold
 * `Support` - Support
 * `Convoy` - Convoy
 * `Build` - Build
 * `Disband` - Disband
 */
export type OrderTypeEnum = (typeof OrderTypeEnum)[keyof typeof OrderTypeEnum];

export const OrderTypeEnum = {
  Move: "Move",
  MoveViaConvoy: "MoveViaConvoy",
  Hold: "Hold",
  Support: "Support",
  Convoy: "Convoy",
  Build: "Build",
  Disband: "Disband",
} as const;

/**
 * * `Army` - Army
 * `Fleet` - Fleet
 */
export type UnitTypeEnum = (typeof UnitTypeEnum)[keyof typeof UnitTypeEnum];

export const UnitTypeEnum = {
  Army: "Army",
  Fleet: "Fleet",
} as const;

/**
 * * `select-order-type` - select-order-type
 * `select-unit-type` - select-unit-type
 * `select-target` - select-target
 * `select-aux` - select-aux
 * `select-named-coast` - select-named-coast
 * `completed` - completed
 */
export type StepEnum = (typeof StepEnum)[keyof typeof StepEnum];

export const StepEnum = {
  "select-order-type": "select-order-type",
  "select-unit-type": "select-unit-type",
  "select-target": "select-target",
  "select-aux": "select-aux",
  "select-named-coast": "select-named-coast",
  completed: "completed",
} as const;

export interface Order {
  readonly source: Province;
  readonly target: Province;
  readonly aux: Province;
  readonly namedCoast: Province;
  readonly resolution: OrderResolution;
  readonly options: readonly OrderOption[];
  readonly orderType: OrderTypeEnum;
  readonly unitType: UnitTypeEnum;
  readonly nation: Nation;
  /** @nullable */
  readonly complete: boolean | null;
  readonly step: StepEnum | NullEnum | null;
  /** @nullable */
  readonly title: string | null;
  /** @nullable */
  readonly summary: string | null;
  selected?: string[];
}

export interface PatchedDrawVoteUpdate {
  accepted?: boolean;
}

export interface PatchedPhaseState {
  readonly id?: string;
  readonly ordersConfirmed?: boolean;
  readonly eliminated?: boolean;
  readonly orderableProvinces?: readonly Province[];
  readonly member?: Member;
}

export interface PatchedUserProfile {
  readonly id?: number;
  /**
   * @minLength 2
   * @maxLength 255
   */
  name?: string;
  /** @nullable */
  readonly picture?: string | null;
  readonly email?: string;
}

/**
 * * `pending` - Pending
 * `active` - Active
 * `completed` - Completed
 * `template` - Template
 */
export type StatusEnum = (typeof StatusEnum)[keyof typeof StatusEnum];

export const StatusEnum = {
  pending: "pending",
  active: "active",
  completed: "completed",
  template: "template",
} as const;

export interface PhaseList {
  id: number;
  ordinal: number;
  season: string;
  year: number;
  name: string;
  type: string;
  status: StatusEnum;
}

/**
 * @nullable
 */
export type UnitDislodgedBy = { [key: string]: unknown } | null | null;

export interface Unit {
  type: string;
  nation: Nation;
  province: Province;
  dislodged: boolean;
  /** @nullable */
  readonly dislodgedBy: UnitDislodgedBy;
}

export interface SupplyCenter {
  province: Province;
  nation: Nation;
}

export interface PhaseRetrieve {
  id: number;
  ordinal: number;
  season: string;
  year: number;
  name: string;
  type: string;
  remainingTime: number;
  scheduledResolution: string;
  status: StatusEnum;
  units: Unit[];
  supplyCenters: SupplyCenter[];
  /** @nullable */
  previousPhaseId: number | null;
  /** @nullable */
  nextPhaseId: number | null;
}

export interface PhaseState {
  readonly id: string;
  readonly ordersConfirmed: boolean;
  readonly eliminated: boolean;
  readonly orderableProvinces: readonly Province[];
  readonly member: Member;
}

export interface TokenRefresh {
  readonly access: string;
  refresh: string;
}

export interface UserProfile {
  readonly id: number;
  /**
   * @minLength 2
   * @maxLength 255
   */
  name: string;
  /** @nullable */
  readonly picture: string | null;
  readonly email: string;
}

export interface Variant {
  id: string;
  name: string;
  description: string;
  author?: string;
  soloVictoryScCount: number;
  nations: Nation[];
  provinces: Province[];
  templatePhase: PhaseRetrieve;
}

export interface Version {
  environment: string;
  version: string;
}

export type ApiSchemaRetrieveParams = {
  format?: ApiSchemaRetrieveFormat;
  lang?: ApiSchemaRetrieveLang;
};

export type ApiSchemaRetrieveFormat =
  (typeof ApiSchemaRetrieveFormat)[keyof typeof ApiSchemaRetrieveFormat];

export const ApiSchemaRetrieveFormat = {
  json: "json",
  yaml: "yaml",
} as const;

export type ApiSchemaRetrieveLang =
  (typeof ApiSchemaRetrieveLang)[keyof typeof ApiSchemaRetrieveLang];

export const ApiSchemaRetrieveLang = {
  af: "af",
  ar: "ar",
  "ar-dz": "ar-dz",
  ast: "ast",
  az: "az",
  be: "be",
  bg: "bg",
  bn: "bn",
  br: "br",
  bs: "bs",
  ca: "ca",
  ckb: "ckb",
  cs: "cs",
  cy: "cy",
  da: "da",
  de: "de",
  dsb: "dsb",
  el: "el",
  en: "en",
  "en-au": "en-au",
  "en-gb": "en-gb",
  eo: "eo",
  es: "es",
  "es-ar": "es-ar",
  "es-co": "es-co",
  "es-mx": "es-mx",
  "es-ni": "es-ni",
  "es-ve": "es-ve",
  et: "et",
  eu: "eu",
  fa: "fa",
  fi: "fi",
  fr: "fr",
  fy: "fy",
  ga: "ga",
  gd: "gd",
  gl: "gl",
  he: "he",
  hi: "hi",
  hr: "hr",
  hsb: "hsb",
  hu: "hu",
  hy: "hy",
  ia: "ia",
  id: "id",
  ig: "ig",
  io: "io",
  is: "is",
  it: "it",
  ja: "ja",
  ka: "ka",
  kab: "kab",
  kk: "kk",
  km: "km",
  kn: "kn",
  ko: "ko",
  ky: "ky",
  lb: "lb",
  lt: "lt",
  lv: "lv",
  mk: "mk",
  ml: "ml",
  mn: "mn",
  mr: "mr",
  ms: "ms",
  my: "my",
  nb: "nb",
  ne: "ne",
  nl: "nl",
  nn: "nn",
  os: "os",
  pa: "pa",
  pl: "pl",
  pt: "pt",
  "pt-br": "pt-br",
  ro: "ro",
  ru: "ru",
  sk: "sk",
  sl: "sl",
  sq: "sq",
  sr: "sr",
  "sr-latn": "sr-latn",
  sv: "sv",
  sw: "sw",
  ta: "ta",
  te: "te",
  tg: "tg",
  th: "th",
  tk: "tk",
  tr: "tr",
  tt: "tt",
  udm: "udm",
  uk: "uk",
  ur: "ur",
  uz: "uz",
  vi: "vi",
  "zh-hans": "zh-hans",
  "zh-hant": "zh-hant",
} as const;

export type ApiSchemaRetrieve200One = { [key: string]: unknown };

export type ApiSchemaRetrieve200Two = { [key: string]: unknown };

export type ApiSchemaRetrieve200Three = { [key: string]: unknown };

export type ApiSchemaRetrieve200Four = { [key: string]: unknown };

export type GamesListParams = {
  can_join?: boolean;
  mine?: boolean;
  sandbox?: boolean;
};

/**
 * OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json
 */
export const apiSchemaRetrieve = (
  params?: ApiSchemaRetrieveParams,
  signal?: AbortSignal
) => {
  return customInstance<
    | Blob
    | ApiSchemaRetrieve200Two
    | ApiSchemaRetrieve200Three
    | ApiSchemaRetrieve200Four
  >({ url: `/api/schema/`, method: "GET", params, signal });
};

export const getApiSchemaRetrieveQueryKey = (
  params?: ApiSchemaRetrieveParams
) => {
  return [`/api/schema/`, ...(params ? [params] : [])] as const;
};

export const getApiSchemaRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiSchemaRetrieve>>
  > = ({ signal }) => apiSchemaRetrieve(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof apiSchemaRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiSchemaRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiSchemaRetrieve>>
>;
export type ApiSchemaRetrieveQueryError = unknown;

export function useApiSchemaRetrieve<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params: undefined | ApiSchemaRetrieveParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiSchemaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiSchemaRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiSchemaRetrieve<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiSchemaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiSchemaRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiSchemaRetrieve<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useApiSchemaRetrieve<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getApiSchemaRetrieveQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getApiSchemaRetrieveSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiSchemaRetrieve>>
  > = ({ signal }) => apiSchemaRetrieve(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof apiSchemaRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiSchemaRetrieveSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiSchemaRetrieve>>
>;
export type ApiSchemaRetrieveSuspenseQueryError = unknown;

export function useApiSchemaRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params: undefined | ApiSchemaRetrieveParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiSchemaRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiSchemaRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useApiSchemaRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>,
  TError = unknown,
>(
  params?: ApiSchemaRetrieveParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiSchemaRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getApiSchemaRetrieveSuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const apiTestSentryRetrieve = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/api/test-sentry/`,
    method: "GET",
    signal,
  });
};

export const getApiTestSentryRetrieveQueryKey = () => {
  return [`/api/test-sentry/`] as const;
};

export const getApiTestSentryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiTestSentryRetrieveQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiTestSentryRetrieve>>
  > = ({ signal }) => apiTestSentryRetrieve(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiTestSentryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiTestSentryRetrieve>>
>;
export type ApiTestSentryRetrieveQueryError = unknown;

export function useApiTestSentryRetrieve<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiTestSentryRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiTestSentryRetrieve<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiTestSentryRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiTestSentryRetrieve<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useApiTestSentryRetrieve<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getApiTestSentryRetrieveQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getApiTestSentryRetrieveSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiTestSentryRetrieveQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiTestSentryRetrieve>>
  > = ({ signal }) => apiTestSentryRetrieve(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiTestSentryRetrieveSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiTestSentryRetrieve>>
>;
export type ApiTestSentryRetrieveSuspenseQueryError = unknown;

export function useApiTestSentryRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiTestSentryRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiTestSentryRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useApiTestSentryRetrieveSuspense<
  TData = Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof apiTestSentryRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getApiTestSentryRetrieveSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const apiTokenRefreshCreate = (
  tokenRefresh: NonReadonly<TokenRefresh>,
  signal?: AbortSignal
) => {
  return customInstance<TokenRefresh>({
    url: `/api/token/refresh/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: tokenRefresh,
    signal,
  });
};

export const getApiTokenRefreshCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationKey = ["apiTokenRefreshCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
    { data: NonReadonly<TokenRefresh> }
  > = props => {
    const { data } = props ?? {};

    return apiTokenRefreshCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApiTokenRefreshCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiTokenRefreshCreate>>
>;
export type ApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>;
export type ApiTokenRefreshCreateMutationError = unknown;

export const useApiTokenRefreshCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
      TError,
      { data: NonReadonly<TokenRefresh> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof apiTokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  return useMutation(
    getApiTokenRefreshCreateMutationOptions(options),
    queryClient
  );
};

export const authLoginCreate = (
  auth: NonReadonly<Auth>,
  signal?: AbortSignal
) => {
  return customInstance<Auth>({
    url: `/auth/login/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: auth,
    signal,
  });
};

export const getAuthLoginCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLoginCreate>>,
    TError,
    { data: NonReadonly<Auth> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLoginCreate>>,
  TError,
  { data: NonReadonly<Auth> },
  TContext
> => {
  const mutationKey = ["authLoginCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLoginCreate>>,
    { data: NonReadonly<Auth> }
  > = props => {
    const { data } = props ?? {};

    return authLoginCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLoginCreate>>
>;
export type AuthLoginCreateMutationBody = NonReadonly<Auth>;
export type AuthLoginCreateMutationError = unknown;

export const useAuthLoginCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLoginCreate>>,
      TError,
      { data: NonReadonly<Auth> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authLoginCreate>>,
  TError,
  { data: NonReadonly<Auth> },
  TContext
> => {
  return useMutation(getAuthLoginCreateMutationOptions(options), queryClient);
};

export const devicesList = (signal?: AbortSignal) => {
  return customInstance<FCMDevice[]>({
    url: `/devices/`,
    method: "GET",
    signal,
  });
};

export const getDevicesListQueryKey = () => {
  return [`/devices/`] as const;
};

export const getDevicesListQueryOptions = <
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof devicesList>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDevicesListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesList>>> = ({
    signal,
  }) => devicesList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof devicesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DevicesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof devicesList>>
>;
export type DevicesListQueryError = unknown;

export function useDevicesList<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof devicesList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesList>>,
          TError,
          Awaited<ReturnType<typeof devicesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDevicesList<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof devicesList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof devicesList>>,
          TError,
          Awaited<ReturnType<typeof devicesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDevicesList<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof devicesList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useDevicesList<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof devicesList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDevicesListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getDevicesListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof devicesList>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDevicesListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof devicesList>>> = ({
    signal,
  }) => devicesList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof devicesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DevicesListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof devicesList>>
>;
export type DevicesListSuspenseQueryError = unknown;

export function useDevicesListSuspense<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof devicesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDevicesListSuspense<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof devicesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDevicesListSuspense<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof devicesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useDevicesListSuspense<
  TData = Awaited<ReturnType<typeof devicesList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof devicesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDevicesListSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const devicesCreate = (
  fCMDevice: NonReadonly<FCMDevice>,
  signal?: AbortSignal
) => {
  return customInstance<FCMDevice>({
    url: `/devices/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: fCMDevice,
    signal,
  });
};

export const getDevicesCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesCreate>>,
    TError,
    { data: NonReadonly<FCMDevice> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesCreate>>,
  TError,
  { data: NonReadonly<FCMDevice> },
  TContext
> => {
  const mutationKey = ["devicesCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesCreate>>,
    { data: NonReadonly<FCMDevice> }
  > = props => {
    const { data } = props ?? {};

    return devicesCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesCreate>>
>;
export type DevicesCreateMutationBody = NonReadonly<FCMDevice>;
export type DevicesCreateMutationError = unknown;

export const useDevicesCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof devicesCreate>>,
      TError,
      { data: NonReadonly<FCMDevice> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof devicesCreate>>,
  TError,
  { data: NonReadonly<FCMDevice> },
  TContext
> => {
  return useMutation(getDevicesCreateMutationOptions(options), queryClient);
};

export const devicesUpdate = (
  fCMDevice: NonReadonly<FCMDevice>,
  signal?: AbortSignal
) => {
  return customInstance<FCMDevice>({
    url: `/devices/`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: fCMDevice,
    signal,
  });
};

export const getDevicesUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof devicesUpdate>>,
    TError,
    { data: NonReadonly<FCMDevice> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof devicesUpdate>>,
  TError,
  { data: NonReadonly<FCMDevice> },
  TContext
> => {
  const mutationKey = ["devicesUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof devicesUpdate>>,
    { data: NonReadonly<FCMDevice> }
  > = props => {
    const { data } = props ?? {};

    return devicesUpdate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DevicesUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof devicesUpdate>>
>;
export type DevicesUpdateMutationBody = NonReadonly<FCMDevice>;
export type DevicesUpdateMutationError = unknown;

export const useDevicesUpdate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof devicesUpdate>>,
      TError,
      { data: NonReadonly<FCMDevice> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof devicesUpdate>>,
  TError,
  { data: NonReadonly<FCMDevice> },
  TContext
> => {
  return useMutation(getDevicesUpdateMutationOptions(options), queryClient);
};

export const gameCreate = (
  gameCreate: NonReadonly<GameCreate>,
  signal?: AbortSignal
) => {
  return customInstance<GameCreate>({
    url: `/game/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: gameCreate,
    signal,
  });
};

export const getGameCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameCreate>>,
    TError,
    { data: NonReadonly<GameCreate> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameCreate>>,
  TError,
  { data: NonReadonly<GameCreate> },
  TContext
> => {
  const mutationKey = ["gameCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameCreate>>,
    { data: NonReadonly<GameCreate> }
  > = props => {
    const { data } = props ?? {};

    return gameCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameCreate>>
>;
export type GameCreateMutationBody = NonReadonly<GameCreate>;
export type GameCreateMutationError = unknown;

export const useGameCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameCreate>>,
      TError,
      { data: NonReadonly<GameCreate> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameCreate>>,
  TError,
  { data: NonReadonly<GameCreate> },
  TContext
> => {
  return useMutation(getGameCreateMutationOptions(options), queryClient);
};

export const gameRetrieve = (gameId: string, signal?: AbortSignal) => {
  return customInstance<GameRetrieve>({
    url: `/game/${gameId}/`,
    method: "GET",
    signal,
  });
};

export const getGameRetrieveQueryKey = (gameId: string) => {
  return [`/game/${gameId}/`] as const;
};

export const getGameRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameRetrieve>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGameRetrieveQueryKey(gameId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gameRetrieve>>> = ({
    signal,
  }) => gameRetrieve(gameId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!gameId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gameRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GameRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof gameRetrieve>>
>;
export type GameRetrieveQueryError = unknown;

export function useGameRetrieve<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gameRetrieve>>,
          TError,
          Awaited<ReturnType<typeof gameRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameRetrieve<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gameRetrieve>>,
          TError,
          Awaited<ReturnType<typeof gameRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameRetrieve<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGameRetrieve<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGameRetrieveQueryOptions(gameId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGameRetrieveSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameRetrieve>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGameRetrieveQueryKey(gameId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gameRetrieve>>> = ({
    signal,
  }) => gameRetrieve(gameId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gameRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GameRetrieveSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gameRetrieve>>
>;
export type GameRetrieveSuspenseQueryError = unknown;

export function useGameRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGameRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gameRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGameRetrieveSuspenseQueryOptions(gameId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gameCloneToSandboxCreate = (
  gameId: string,
  gameCloneToSandbox: NonReadonly<GameCloneToSandbox>,
  signal?: AbortSignal
) => {
  return customInstance<GameCloneToSandbox>({
    url: `/game/${gameId}/clone-to-sandbox/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: gameCloneToSandbox,
    signal,
  });
};

export const getGameCloneToSandboxCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameCloneToSandboxCreate>>,
    TError,
    { gameId: string; data: NonReadonly<GameCloneToSandbox> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameCloneToSandboxCreate>>,
  TError,
  { gameId: string; data: NonReadonly<GameCloneToSandbox> },
  TContext
> => {
  const mutationKey = ["gameCloneToSandboxCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameCloneToSandboxCreate>>,
    { gameId: string; data: NonReadonly<GameCloneToSandbox> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gameCloneToSandboxCreate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameCloneToSandboxCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameCloneToSandboxCreate>>
>;
export type GameCloneToSandboxCreateMutationBody =
  NonReadonly<GameCloneToSandbox>;
export type GameCloneToSandboxCreateMutationError = unknown;

export const useGameCloneToSandboxCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameCloneToSandboxCreate>>,
      TError,
      { gameId: string; data: NonReadonly<GameCloneToSandbox> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameCloneToSandboxCreate>>,
  TError,
  { gameId: string; data: NonReadonly<GameCloneToSandbox> },
  TContext
> => {
  return useMutation(
    getGameCloneToSandboxCreateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gameConfirmPhaseUpdate = (
  gameId: string,
  phaseState: NonReadonly<PhaseState>,
  signal?: AbortSignal
) => {
  return customInstance<PhaseState>({
    url: `/game/${gameId}/confirm-phase/`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: phaseState,
    signal,
  });
};

export const getGameConfirmPhaseUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameConfirmPhaseUpdate>>,
    TError,
    { gameId: string; data: NonReadonly<PhaseState> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameConfirmPhaseUpdate>>,
  TError,
  { gameId: string; data: NonReadonly<PhaseState> },
  TContext
> => {
  const mutationKey = ["gameConfirmPhaseUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameConfirmPhaseUpdate>>,
    { gameId: string; data: NonReadonly<PhaseState> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gameConfirmPhaseUpdate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameConfirmPhaseUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameConfirmPhaseUpdate>>
>;
export type GameConfirmPhaseUpdateMutationBody = NonReadonly<PhaseState>;
export type GameConfirmPhaseUpdateMutationError = unknown;

export const useGameConfirmPhaseUpdate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameConfirmPhaseUpdate>>,
      TError,
      { gameId: string; data: NonReadonly<PhaseState> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameConfirmPhaseUpdate>>,
  TError,
  { gameId: string; data: NonReadonly<PhaseState> },
  TContext
> => {
  return useMutation(
    getGameConfirmPhaseUpdateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gameConfirmPhasePartialUpdate = (
  gameId: string,
  patchedPhaseState: NonReadonly<PatchedPhaseState>,
  signal?: AbortSignal
) => {
  return customInstance<PhaseState>({
    url: `/game/${gameId}/confirm-phase/`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedPhaseState,
    signal,
  });
};

export const getGameConfirmPhasePartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameConfirmPhasePartialUpdate>>,
    TError,
    { gameId: string; data: NonReadonly<PatchedPhaseState> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameConfirmPhasePartialUpdate>>,
  TError,
  { gameId: string; data: NonReadonly<PatchedPhaseState> },
  TContext
> => {
  const mutationKey = ["gameConfirmPhasePartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameConfirmPhasePartialUpdate>>,
    { gameId: string; data: NonReadonly<PatchedPhaseState> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gameConfirmPhasePartialUpdate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameConfirmPhasePartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameConfirmPhasePartialUpdate>>
>;
export type GameConfirmPhasePartialUpdateMutationBody =
  NonReadonly<PatchedPhaseState>;
export type GameConfirmPhasePartialUpdateMutationError = unknown;

export const useGameConfirmPhasePartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameConfirmPhasePartialUpdate>>,
      TError,
      { gameId: string; data: NonReadonly<PatchedPhaseState> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameConfirmPhasePartialUpdate>>,
  TError,
  { gameId: string; data: NonReadonly<PatchedPhaseState> },
  TContext
> => {
  return useMutation(
    getGameConfirmPhasePartialUpdateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gameJoinCreate = (
  gameId: string,
  member: NonReadonly<Member>,
  signal?: AbortSignal
) => {
  return customInstance<Member>({
    url: `/game/${gameId}/join/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: member,
    signal,
  });
};

export const getGameJoinCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameJoinCreate>>,
    TError,
    { gameId: string; data: NonReadonly<Member> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameJoinCreate>>,
  TError,
  { gameId: string; data: NonReadonly<Member> },
  TContext
> => {
  const mutationKey = ["gameJoinCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameJoinCreate>>,
    { gameId: string; data: NonReadonly<Member> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gameJoinCreate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameJoinCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameJoinCreate>>
>;
export type GameJoinCreateMutationBody = NonReadonly<Member>;
export type GameJoinCreateMutationError = unknown;

export const useGameJoinCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameJoinCreate>>,
      TError,
      { gameId: string; data: NonReadonly<Member> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameJoinCreate>>,
  TError,
  { gameId: string; data: NonReadonly<Member> },
  TContext
> => {
  return useMutation(getGameJoinCreateMutationOptions(options), queryClient);
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gameLeaveDestroy = (gameId: string, signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/game/${gameId}/leave/`,
    method: "DELETE",
    signal,
  });
};

export const getGameLeaveDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameLeaveDestroy>>,
    TError,
    { gameId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameLeaveDestroy>>,
  TError,
  { gameId: string },
  TContext
> => {
  const mutationKey = ["gameLeaveDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameLeaveDestroy>>,
    { gameId: string }
  > = props => {
    const { gameId } = props ?? {};

    return gameLeaveDestroy(gameId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameLeaveDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameLeaveDestroy>>
>;

export type GameLeaveDestroyMutationError = unknown;

export const useGameLeaveDestroy = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameLeaveDestroy>>,
      TError,
      { gameId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameLeaveDestroy>>,
  TError,
  { gameId: string },
  TContext
> => {
  return useMutation(getGameLeaveDestroyMutationOptions(options), queryClient);
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_phase
method that returns the current phase for the game. Also adds phase to the serializer context.
 */
export const gameOrdersCreate = (
  gameId: string,
  order: NonReadonly<Order>,
  signal?: AbortSignal
) => {
  return customInstance<Order>({
    url: `/game/${gameId}/orders/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: order,
    signal,
  });
};

export const getGameOrdersCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameOrdersCreate>>,
    TError,
    { gameId: string; data: NonReadonly<Order> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameOrdersCreate>>,
  TError,
  { gameId: string; data: NonReadonly<Order> },
  TContext
> => {
  const mutationKey = ["gameOrdersCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameOrdersCreate>>,
    { gameId: string; data: NonReadonly<Order> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gameOrdersCreate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameOrdersCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameOrdersCreate>>
>;
export type GameOrdersCreateMutationBody = NonReadonly<Order>;
export type GameOrdersCreateMutationError = unknown;

export const useGameOrdersCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameOrdersCreate>>,
      TError,
      { gameId: string; data: NonReadonly<Order> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameOrdersCreate>>,
  TError,
  { gameId: string; data: NonReadonly<Order> },
  TContext
> => {
  return useMutation(getGameOrdersCreateMutationOptions(options), queryClient);
};

/**
 * Used by views that have a phase parameter in the URL. Provides a get_phase
method that returns the phase object. Also adds phase to the serializer context.
 */
export const gameOrdersList = (
  gameId: string,
  phaseId: number,
  signal?: AbortSignal
) => {
  return customInstance<Order[]>({
    url: `/game/${gameId}/orders/${phaseId}`,
    method: "GET",
    signal,
  });
};

export const getGameOrdersListQueryKey = (gameId: string, phaseId: number) => {
  return [`/game/${gameId}/orders/${phaseId}`] as const;
};

export const getGameOrdersListQueryOptions = <
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameOrdersList>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGameOrdersListQueryKey(gameId, phaseId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gameOrdersList>>> = ({
    signal,
  }) => gameOrdersList(gameId, phaseId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(gameId && phaseId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gameOrdersList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GameOrdersListQueryResult = NonNullable<
  Awaited<ReturnType<typeof gameOrdersList>>
>;
export type GameOrdersListQueryError = unknown;

export function useGameOrdersList<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameOrdersList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gameOrdersList>>,
          TError,
          Awaited<ReturnType<typeof gameOrdersList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameOrdersList<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameOrdersList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gameOrdersList>>,
          TError,
          Awaited<ReturnType<typeof gameOrdersList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameOrdersList<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameOrdersList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGameOrdersList<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gameOrdersList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGameOrdersListQueryOptions(gameId, phaseId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGameOrdersListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameOrdersList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGameOrdersListQueryKey(gameId, phaseId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gameOrdersList>>> = ({
    signal,
  }) => gameOrdersList(gameId, phaseId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gameOrdersList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GameOrdersListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gameOrdersList>>
>;
export type GameOrdersListSuspenseQueryError = unknown;

export function useGameOrdersListSuspense<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameOrdersList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameOrdersListSuspense<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameOrdersList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGameOrdersListSuspense<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameOrdersList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGameOrdersListSuspense<
  TData = Awaited<ReturnType<typeof gameOrdersList>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gameOrdersList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGameOrdersListSuspenseQueryOptions(
    gameId,
    phaseId,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_phase
method that returns the current phase for the game. Also adds phase to the serializer context.
 */
export const gameOrdersDeleteDestroy = (
  gameId: string,
  sourceId: string,
  signal?: AbortSignal
) => {
  return customInstance<void>({
    url: `/game/${gameId}/orders/delete/${sourceId}`,
    method: "DELETE",
    signal,
  });
};

export const getGameOrdersDeleteDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameOrdersDeleteDestroy>>,
    TError,
    { gameId: string; sourceId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameOrdersDeleteDestroy>>,
  TError,
  { gameId: string; sourceId: string },
  TContext
> => {
  const mutationKey = ["gameOrdersDeleteDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameOrdersDeleteDestroy>>,
    { gameId: string; sourceId: string }
  > = props => {
    const { gameId, sourceId } = props ?? {};

    return gameOrdersDeleteDestroy(gameId, sourceId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameOrdersDeleteDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameOrdersDeleteDestroy>>
>;

export type GameOrdersDeleteDestroyMutationError = unknown;

export const useGameOrdersDeleteDestroy = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameOrdersDeleteDestroy>>,
      TError,
      { gameId: string; sourceId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameOrdersDeleteDestroy>>,
  TError,
  { gameId: string; sourceId: string },
  TContext
> => {
  return useMutation(
    getGameOrdersDeleteDestroyMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamePhaseStatesList = (gameId: string, signal?: AbortSignal) => {
  return customInstance<PhaseState[]>({
    url: `/game/${gameId}/phase-states/`,
    method: "GET",
    signal,
  });
};

export const getGamePhaseStatesListQueryKey = (gameId: string) => {
  return [`/game/${gameId}/phase-states/`] as const;
};

export const getGamePhaseStatesListQueryOptions = <
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamePhaseStatesListQueryKey(gameId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamePhaseStatesList>>
  > = ({ signal }) => gamePhaseStatesList(gameId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!gameId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gamePhaseStatesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamePhaseStatesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamePhaseStatesList>>
>;
export type GamePhaseStatesListQueryError = unknown;

export function useGamePhaseStatesList<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamePhaseStatesList>>,
          TError,
          Awaited<ReturnType<typeof gamePhaseStatesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseStatesList<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamePhaseStatesList>>,
          TError,
          Awaited<ReturnType<typeof gamePhaseStatesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseStatesList<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamePhaseStatesList<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamePhaseStatesListQueryOptions(gameId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGamePhaseStatesListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamePhaseStatesListQueryKey(gameId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamePhaseStatesList>>
  > = ({ signal }) => gamePhaseStatesList(gameId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gamePhaseStatesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamePhaseStatesListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamePhaseStatesList>>
>;
export type GamePhaseStatesListSuspenseQueryError = unknown;

export function useGamePhaseStatesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseStatesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseStatesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamePhaseStatesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseStatesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseStatesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamePhaseStatesListSuspenseQueryOptions(
    gameId,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const gamePhaseRetrieve = (
  gameId: string,
  phaseId: number,
  signal?: AbortSignal
) => {
  return customInstance<PhaseRetrieve>({
    url: `/game/${gameId}/phase/${phaseId}/`,
    method: "GET",
    signal,
  });
};

export const getGamePhaseRetrieveQueryKey = (
  gameId: string,
  phaseId: number
) => {
  return [`/game/${gameId}/phase/${phaseId}/`] as const;
};

export const getGamePhaseRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamePhaseRetrieveQueryKey(gameId, phaseId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamePhaseRetrieve>>
  > = ({ signal }) => gamePhaseRetrieve(gameId, phaseId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(gameId && phaseId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gamePhaseRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamePhaseRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamePhaseRetrieve>>
>;
export type GamePhaseRetrieveQueryError = unknown;

export function useGamePhaseRetrieve<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamePhaseRetrieve>>,
          TError,
          Awaited<ReturnType<typeof gamePhaseRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseRetrieve<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamePhaseRetrieve>>,
          TError,
          Awaited<ReturnType<typeof gamePhaseRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseRetrieve<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamePhaseRetrieve<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamePhaseRetrieveQueryOptions(
    gameId,
    phaseId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGamePhaseRetrieveSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamePhaseRetrieveQueryKey(gameId, phaseId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamePhaseRetrieve>>
  > = ({ signal }) => gamePhaseRetrieve(gameId, phaseId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gamePhaseRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamePhaseRetrieveSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamePhaseRetrieve>>
>;
export type GamePhaseRetrieveSuspenseQueryError = unknown;

export function useGamePhaseRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhaseRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamePhaseRetrieveSuspense<
  TData = Awaited<ReturnType<typeof gamePhaseRetrieve>>,
  TError = unknown,
>(
  gameId: string,
  phaseId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhaseRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamePhaseRetrieveSuspenseQueryOptions(
    gameId,
    phaseId,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamePhasesList = (gameId: string, signal?: AbortSignal) => {
  return customInstance<PhaseList[]>({
    url: `/game/${gameId}/phases/`,
    method: "GET",
    signal,
  });
};

export const getGamePhasesListQueryKey = (gameId: string) => {
  return [`/game/${gameId}/phases/`] as const;
};

export const getGamePhasesListQueryOptions = <
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamePhasesList>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGamePhasesListQueryKey(gameId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gamePhasesList>>> = ({
    signal,
  }) => gamePhasesList(gameId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!gameId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gamePhasesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamePhasesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamePhasesList>>
>;
export type GamePhasesListQueryError = unknown;

export function useGamePhasesList<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamePhasesList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamePhasesList>>,
          TError,
          Awaited<ReturnType<typeof gamePhasesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhasesList<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamePhasesList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamePhasesList>>,
          TError,
          Awaited<ReturnType<typeof gamePhasesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhasesList<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamePhasesList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamePhasesList<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamePhasesList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamePhasesListQueryOptions(gameId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGamePhasesListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhasesList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGamePhasesListQueryKey(gameId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gamePhasesList>>> = ({
    signal,
  }) => gamePhasesList(gameId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gamePhasesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamePhasesListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamePhasesList>>
>;
export type GamePhasesListSuspenseQueryError = unknown;

export function useGamePhasesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhasesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhasesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhasesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamePhasesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhasesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamePhasesListSuspense<
  TData = Awaited<ReturnType<typeof gamePhasesList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamePhasesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamePhasesListSuspenseQueryOptions(gameId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gameResolvePhaseCreate = (
  gameId: string,
  signal?: AbortSignal
) => {
  return customInstance<PhaseList>({
    url: `/game/${gameId}/resolve-phase/`,
    method: "POST",
    signal,
  });
};

export const getGameResolvePhaseCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gameResolvePhaseCreate>>,
    TError,
    { gameId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gameResolvePhaseCreate>>,
  TError,
  { gameId: string },
  TContext
> => {
  const mutationKey = ["gameResolvePhaseCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gameResolvePhaseCreate>>,
    { gameId: string }
  > = props => {
    const { gameId } = props ?? {};

    return gameResolvePhaseCreate(gameId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GameResolvePhaseCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gameResolvePhaseCreate>>
>;

export type GameResolvePhaseCreateMutationError = unknown;

export const useGameResolvePhaseCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gameResolvePhaseCreate>>,
      TError,
      { gameId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gameResolvePhaseCreate>>,
  TError,
  { gameId: string },
  TContext
> => {
  return useMutation(
    getGameResolvePhaseCreateMutationOptions(options),
    queryClient
  );
};

export const gamesList = (params?: GamesListParams, signal?: AbortSignal) => {
  return customInstance<GameList[]>({
    url: `/games/`,
    method: "GET",
    params,
    signal,
  });
};

export const getGamesListQueryKey = (params?: GamesListParams) => {
  return [`/games/`, ...(params ? [params] : [])] as const;
};

export const getGamesListQueryOptions = <
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamesList>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGamesListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gamesList>>> = ({
    signal,
  }) => gamesList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof gamesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamesList>>
>;
export type GamesListQueryError = unknown;

export function useGamesList<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params: undefined | GamesListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamesList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamesList>>,
          TError,
          Awaited<ReturnType<typeof gamesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesList<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamesList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamesList>>,
          TError,
          Awaited<ReturnType<typeof gamesList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesList<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamesList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamesList<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof gamesList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamesListQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGamesListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGamesListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof gamesList>>> = ({
    signal,
  }) => gamesList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gamesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamesListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamesList>>
>;
export type GamesListSuspenseQueryError = unknown;

export function useGamesListSuspense<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params: undefined | GamesListParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesListSuspense<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesListSuspense<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamesListSuspense<
  TData = Awaited<ReturnType<typeof gamesList>>,
  TError = unknown,
>(
  params?: GamesListParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamesListSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesChannelsList = (gameId: string, signal?: AbortSignal) => {
  return customInstance<Channel[]>({
    url: `/games/${gameId}/channels/`,
    method: "GET",
    signal,
  });
};

export const getGamesChannelsListQueryKey = (gameId: string) => {
  return [`/games/${gameId}/channels/`] as const;
};

export const getGamesChannelsListQueryOptions = <
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamesChannelsListQueryKey(gameId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamesChannelsList>>
  > = ({ signal }) => gamesChannelsList(gameId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!gameId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gamesChannelsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamesChannelsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamesChannelsList>>
>;
export type GamesChannelsListQueryError = unknown;

export function useGamesChannelsList<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamesChannelsList>>,
          TError,
          Awaited<ReturnType<typeof gamesChannelsList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesChannelsList<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamesChannelsList>>,
          TError,
          Awaited<ReturnType<typeof gamesChannelsList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesChannelsList<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamesChannelsList<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamesChannelsListQueryOptions(gameId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGamesChannelsListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamesChannelsListQueryKey(gameId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamesChannelsList>>
  > = ({ signal }) => gamesChannelsList(gameId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gamesChannelsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamesChannelsListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamesChannelsList>>
>;
export type GamesChannelsListSuspenseQueryError = unknown;

export function useGamesChannelsListSuspense<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesChannelsListSuspense<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesChannelsListSuspense<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamesChannelsListSuspense<
  TData = Awaited<ReturnType<typeof gamesChannelsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesChannelsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamesChannelsListSuspenseQueryOptions(
    gameId,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesChannelsMessagesCreateCreate = (
  gameId: string,
  channelId: number,
  channelMessage: NonReadonly<ChannelMessage>,
  signal?: AbortSignal
) => {
  return customInstance<ChannelMessage>({
    url: `/games/${gameId}/channels/${channelId}/messages/create/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: channelMessage,
    signal,
  });
};

export const getGamesChannelsMessagesCreateCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gamesChannelsMessagesCreateCreate>>,
    TError,
    { gameId: string; channelId: number; data: NonReadonly<ChannelMessage> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gamesChannelsMessagesCreateCreate>>,
  TError,
  { gameId: string; channelId: number; data: NonReadonly<ChannelMessage> },
  TContext
> => {
  const mutationKey = ["gamesChannelsMessagesCreateCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gamesChannelsMessagesCreateCreate>>,
    { gameId: string; channelId: number; data: NonReadonly<ChannelMessage> }
  > = props => {
    const { gameId, channelId, data } = props ?? {};

    return gamesChannelsMessagesCreateCreate(gameId, channelId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GamesChannelsMessagesCreateCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gamesChannelsMessagesCreateCreate>>
>;
export type GamesChannelsMessagesCreateCreateMutationBody =
  NonReadonly<ChannelMessage>;
export type GamesChannelsMessagesCreateCreateMutationError = unknown;

export const useGamesChannelsMessagesCreateCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gamesChannelsMessagesCreateCreate>>,
      TError,
      { gameId: string; channelId: number; data: NonReadonly<ChannelMessage> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gamesChannelsMessagesCreateCreate>>,
  TError,
  { gameId: string; channelId: number; data: NonReadonly<ChannelMessage> },
  TContext
> => {
  return useMutation(
    getGamesChannelsMessagesCreateCreateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesChannelsCreateCreate = (
  gameId: string,
  channel: NonReadonly<Channel>,
  signal?: AbortSignal
) => {
  return customInstance<Channel>({
    url: `/games/${gameId}/channels/create/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: channel,
    signal,
  });
};

export const getGamesChannelsCreateCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gamesChannelsCreateCreate>>,
    TError,
    { gameId: string; data: NonReadonly<Channel> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gamesChannelsCreateCreate>>,
  TError,
  { gameId: string; data: NonReadonly<Channel> },
  TContext
> => {
  const mutationKey = ["gamesChannelsCreateCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gamesChannelsCreateCreate>>,
    { gameId: string; data: NonReadonly<Channel> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gamesChannelsCreateCreate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GamesChannelsCreateCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gamesChannelsCreateCreate>>
>;
export type GamesChannelsCreateCreateMutationBody = NonReadonly<Channel>;
export type GamesChannelsCreateCreateMutationError = unknown;

export const useGamesChannelsCreateCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gamesChannelsCreateCreate>>,
      TError,
      { gameId: string; data: NonReadonly<Channel> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gamesChannelsCreateCreate>>,
  TError,
  { gameId: string; data: NonReadonly<Channel> },
  TContext
> => {
  return useMutation(
    getGamesChannelsCreateCreateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesDrawProposalsList = (
  gameId: string,
  signal?: AbortSignal
) => {
  return customInstance<DrawProposal[]>({
    url: `/games/${gameId}/draw-proposals/`,
    method: "GET",
    signal,
  });
};

export const getGamesDrawProposalsListQueryKey = (gameId: string) => {
  return [`/games/${gameId}/draw-proposals/`] as const;
};

export const getGamesDrawProposalsListQueryOptions = <
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamesDrawProposalsListQueryKey(gameId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamesDrawProposalsList>>
  > = ({ signal }) => gamesDrawProposalsList(gameId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!gameId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof gamesDrawProposalsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamesDrawProposalsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamesDrawProposalsList>>
>;
export type GamesDrawProposalsListQueryError = unknown;

export function useGamesDrawProposalsList<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamesDrawProposalsList>>,
          TError,
          Awaited<ReturnType<typeof gamesDrawProposalsList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesDrawProposalsList<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gamesDrawProposalsList>>,
          TError,
          Awaited<ReturnType<typeof gamesDrawProposalsList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesDrawProposalsList<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamesDrawProposalsList<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamesDrawProposalsListQueryOptions(gameId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getGamesDrawProposalsListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGamesDrawProposalsListQueryKey(gameId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof gamesDrawProposalsList>>
  > = ({ signal }) => gamesDrawProposalsList(gameId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof gamesDrawProposalsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GamesDrawProposalsListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof gamesDrawProposalsList>>
>;
export type GamesDrawProposalsListSuspenseQueryError = unknown;

export function useGamesDrawProposalsListSuspense<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesDrawProposalsListSuspense<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGamesDrawProposalsListSuspense<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGamesDrawProposalsListSuspense<
  TData = Awaited<ReturnType<typeof gamesDrawProposalsList>>,
  TError = unknown,
>(
  gameId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof gamesDrawProposalsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGamesDrawProposalsListSuspenseQueryOptions(
    gameId,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesDrawProposalsCancelDestroy = (
  gameId: string,
  proposalId: number,
  signal?: AbortSignal
) => {
  return customInstance<void>({
    url: `/games/${gameId}/draw-proposals/${proposalId}/cancel/`,
    method: "DELETE",
    signal,
  });
};

export const getGamesDrawProposalsCancelDestroyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gamesDrawProposalsCancelDestroy>>,
    TError,
    { gameId: string; proposalId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gamesDrawProposalsCancelDestroy>>,
  TError,
  { gameId: string; proposalId: number },
  TContext
> => {
  const mutationKey = ["gamesDrawProposalsCancelDestroy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gamesDrawProposalsCancelDestroy>>,
    { gameId: string; proposalId: number }
  > = props => {
    const { gameId, proposalId } = props ?? {};

    return gamesDrawProposalsCancelDestroy(gameId, proposalId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GamesDrawProposalsCancelDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof gamesDrawProposalsCancelDestroy>>
>;

export type GamesDrawProposalsCancelDestroyMutationError = unknown;

export const useGamesDrawProposalsCancelDestroy = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gamesDrawProposalsCancelDestroy>>,
      TError,
      { gameId: string; proposalId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gamesDrawProposalsCancelDestroy>>,
  TError,
  { gameId: string; proposalId: number },
  TContext
> => {
  return useMutation(
    getGamesDrawProposalsCancelDestroyMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesDrawProposalsVoteUpdate = (
  gameId: string,
  proposalId: number,
  drawVoteUpdate: DrawVoteUpdate,
  signal?: AbortSignal
) => {
  return customInstance<DrawVoteUpdate>({
    url: `/games/${gameId}/draw-proposals/${proposalId}/vote/`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: drawVoteUpdate,
    signal,
  });
};

export const getGamesDrawProposalsVoteUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gamesDrawProposalsVoteUpdate>>,
    TError,
    { gameId: string; proposalId: number; data: DrawVoteUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gamesDrawProposalsVoteUpdate>>,
  TError,
  { gameId: string; proposalId: number; data: DrawVoteUpdate },
  TContext
> => {
  const mutationKey = ["gamesDrawProposalsVoteUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gamesDrawProposalsVoteUpdate>>,
    { gameId: string; proposalId: number; data: DrawVoteUpdate }
  > = props => {
    const { gameId, proposalId, data } = props ?? {};

    return gamesDrawProposalsVoteUpdate(gameId, proposalId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GamesDrawProposalsVoteUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gamesDrawProposalsVoteUpdate>>
>;
export type GamesDrawProposalsVoteUpdateMutationBody = DrawVoteUpdate;
export type GamesDrawProposalsVoteUpdateMutationError = unknown;

export const useGamesDrawProposalsVoteUpdate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gamesDrawProposalsVoteUpdate>>,
      TError,
      { gameId: string; proposalId: number; data: DrawVoteUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gamesDrawProposalsVoteUpdate>>,
  TError,
  { gameId: string; proposalId: number; data: DrawVoteUpdate },
  TContext
> => {
  return useMutation(
    getGamesDrawProposalsVoteUpdateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesDrawProposalsVotePartialUpdate = (
  gameId: string,
  proposalId: number,
  patchedDrawVoteUpdate: PatchedDrawVoteUpdate,
  signal?: AbortSignal
) => {
  return customInstance<DrawVoteUpdate>({
    url: `/games/${gameId}/draw-proposals/${proposalId}/vote/`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedDrawVoteUpdate,
    signal,
  });
};

export const getGamesDrawProposalsVotePartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gamesDrawProposalsVotePartialUpdate>>,
    TError,
    { gameId: string; proposalId: number; data: PatchedDrawVoteUpdate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gamesDrawProposalsVotePartialUpdate>>,
  TError,
  { gameId: string; proposalId: number; data: PatchedDrawVoteUpdate },
  TContext
> => {
  const mutationKey = ["gamesDrawProposalsVotePartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gamesDrawProposalsVotePartialUpdate>>,
    { gameId: string; proposalId: number; data: PatchedDrawVoteUpdate }
  > = props => {
    const { gameId, proposalId, data } = props ?? {};

    return gamesDrawProposalsVotePartialUpdate(gameId, proposalId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GamesDrawProposalsVotePartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gamesDrawProposalsVotePartialUpdate>>
>;
export type GamesDrawProposalsVotePartialUpdateMutationBody =
  PatchedDrawVoteUpdate;
export type GamesDrawProposalsVotePartialUpdateMutationError = unknown;

export const useGamesDrawProposalsVotePartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gamesDrawProposalsVotePartialUpdate>>,
      TError,
      { gameId: string; proposalId: number; data: PatchedDrawVoteUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gamesDrawProposalsVotePartialUpdate>>,
  TError,
  { gameId: string; proposalId: number; data: PatchedDrawVoteUpdate },
  TContext
> => {
  return useMutation(
    getGamesDrawProposalsVotePartialUpdateMutationOptions(options),
    queryClient
  );
};

/**
 * Used by views that have a game parameter in the URL. Provides a get_game
method that returns the game object. Also adds game to the serializer context.
 */
export const gamesDrawProposalsCreateCreate = (
  gameId: string,
  drawProposal: NonReadonly<DrawProposal>,
  signal?: AbortSignal
) => {
  return customInstance<DrawProposal>({
    url: `/games/${gameId}/draw-proposals/create/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: drawProposal,
    signal,
  });
};

export const getGamesDrawProposalsCreateCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gamesDrawProposalsCreateCreate>>,
    TError,
    { gameId: string; data: NonReadonly<DrawProposal> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gamesDrawProposalsCreateCreate>>,
  TError,
  { gameId: string; data: NonReadonly<DrawProposal> },
  TContext
> => {
  const mutationKey = ["gamesDrawProposalsCreateCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gamesDrawProposalsCreateCreate>>,
    { gameId: string; data: NonReadonly<DrawProposal> }
  > = props => {
    const { gameId, data } = props ?? {};

    return gamesDrawProposalsCreateCreate(gameId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GamesDrawProposalsCreateCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof gamesDrawProposalsCreateCreate>>
>;
export type GamesDrawProposalsCreateCreateMutationBody =
  NonReadonly<DrawProposal>;
export type GamesDrawProposalsCreateCreateMutationError = unknown;

export const useGamesDrawProposalsCreateCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gamesDrawProposalsCreateCreate>>,
      TError,
      { gameId: string; data: NonReadonly<DrawProposal> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof gamesDrawProposalsCreateCreate>>,
  TError,
  { gameId: string; data: NonReadonly<DrawProposal> },
  TContext
> => {
  return useMutation(
    getGamesDrawProposalsCreateCreateMutationOptions(options),
    queryClient
  );
};

export const phaseResolveCreate = (signal?: AbortSignal) => {
  return customInstance<void>({
    url: `/phase/resolve/`,
    method: "POST",
    signal,
  });
};

export const getPhaseResolveCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof phaseResolveCreate>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof phaseResolveCreate>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["phaseResolveCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof phaseResolveCreate>>,
    void
  > = () => {
    return phaseResolveCreate();
  };

  return { mutationFn, ...mutationOptions };
};

export type PhaseResolveCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof phaseResolveCreate>>
>;

export type PhaseResolveCreateMutationError = unknown;

export const usePhaseResolveCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof phaseResolveCreate>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof phaseResolveCreate>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getPhaseResolveCreateMutationOptions(options),
    queryClient
  );
};

export const sandboxGameCreate = (
  gameCreateSandbox: NonReadonly<GameCreateSandbox>,
  signal?: AbortSignal
) => {
  return customInstance<GameCreateSandbox>({
    url: `/sandbox-game/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: gameCreateSandbox,
    signal,
  });
};

export const getSandboxGameCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sandboxGameCreate>>,
    TError,
    { data: NonReadonly<GameCreateSandbox> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sandboxGameCreate>>,
  TError,
  { data: NonReadonly<GameCreateSandbox> },
  TContext
> => {
  const mutationKey = ["sandboxGameCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sandboxGameCreate>>,
    { data: NonReadonly<GameCreateSandbox> }
  > = props => {
    const { data } = props ?? {};

    return sandboxGameCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SandboxGameCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof sandboxGameCreate>>
>;
export type SandboxGameCreateMutationBody = NonReadonly<GameCreateSandbox>;
export type SandboxGameCreateMutationError = unknown;

export const useSandboxGameCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sandboxGameCreate>>,
      TError,
      { data: NonReadonly<GameCreateSandbox> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sandboxGameCreate>>,
  TError,
  { data: NonReadonly<GameCreateSandbox> },
  TContext
> => {
  return useMutation(getSandboxGameCreateMutationOptions(options), queryClient);
};

export const userRetrieve = (signal?: AbortSignal) => {
  return customInstance<UserProfile>({ url: `/user/`, method: "GET", signal });
};

export const getUserRetrieveQueryKey = () => {
  return [`/user/`] as const;
};

export const getUserRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserRetrieveQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userRetrieve>>> = ({
    signal,
  }) => userRetrieve(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof userRetrieve>>
>;
export type UserRetrieveQueryError = unknown;

export function useUserRetrieve<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userRetrieve>>,
          TError,
          Awaited<ReturnType<typeof userRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserRetrieve<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userRetrieve>>,
          TError,
          Awaited<ReturnType<typeof userRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserRetrieve<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useUserRetrieve<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserRetrieveQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getUserRetrieveSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof userRetrieve>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserRetrieveQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userRetrieve>>> = ({
    signal,
  }) => userRetrieve(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof userRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserRetrieveSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof userRetrieve>>
>;
export type UserRetrieveSuspenseQueryError = unknown;

export function useUserRetrieveSuspense<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserRetrieveSuspense<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserRetrieveSuspense<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useUserRetrieveSuspense<
  TData = Awaited<ReturnType<typeof userRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserRetrieveSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const userUpdateUpdate = (
  userProfile: NonReadonly<UserProfile>,
  signal?: AbortSignal
) => {
  return customInstance<UserProfile>({
    url: `/user/update/`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: userProfile,
    signal,
  });
};

export const getUserUpdateUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdateUpdate>>,
    TError,
    { data: NonReadonly<UserProfile> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userUpdateUpdate>>,
  TError,
  { data: NonReadonly<UserProfile> },
  TContext
> => {
  const mutationKey = ["userUpdateUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userUpdateUpdate>>,
    { data: NonReadonly<UserProfile> }
  > = props => {
    const { data } = props ?? {};

    return userUpdateUpdate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserUpdateUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userUpdateUpdate>>
>;
export type UserUpdateUpdateMutationBody = NonReadonly<UserProfile>;
export type UserUpdateUpdateMutationError = unknown;

export const useUserUpdateUpdate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userUpdateUpdate>>,
      TError,
      { data: NonReadonly<UserProfile> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userUpdateUpdate>>,
  TError,
  { data: NonReadonly<UserProfile> },
  TContext
> => {
  return useMutation(getUserUpdateUpdateMutationOptions(options), queryClient);
};

export const userUpdatePartialUpdate = (
  patchedUserProfile: NonReadonly<PatchedUserProfile>,
  signal?: AbortSignal
) => {
  return customInstance<UserProfile>({
    url: `/user/update/`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: patchedUserProfile,
    signal,
  });
};

export const getUserUpdatePartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdatePartialUpdate>>,
    TError,
    { data: NonReadonly<PatchedUserProfile> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userUpdatePartialUpdate>>,
  TError,
  { data: NonReadonly<PatchedUserProfile> },
  TContext
> => {
  const mutationKey = ["userUpdatePartialUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userUpdatePartialUpdate>>,
    { data: NonReadonly<PatchedUserProfile> }
  > = props => {
    const { data } = props ?? {};

    return userUpdatePartialUpdate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserUpdatePartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userUpdatePartialUpdate>>
>;
export type UserUpdatePartialUpdateMutationBody =
  NonReadonly<PatchedUserProfile>;
export type UserUpdatePartialUpdateMutationError = unknown;

export const useUserUpdatePartialUpdate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userUpdatePartialUpdate>>,
      TError,
      { data: NonReadonly<PatchedUserProfile> },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userUpdatePartialUpdate>>,
  TError,
  { data: NonReadonly<PatchedUserProfile> },
  TContext
> => {
  return useMutation(
    getUserUpdatePartialUpdateMutationOptions(options),
    queryClient
  );
};

export const variantsList = (signal?: AbortSignal) => {
  return customInstance<Variant[]>({
    url: `/variants/`,
    method: "GET",
    signal,
  });
};

export const getVariantsListQueryKey = () => {
  return [`/variants/`] as const;
};

export const getVariantsListQueryOptions = <
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof variantsList>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVariantsListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof variantsList>>> = ({
    signal,
  }) => variantsList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof variantsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VariantsListQueryResult = NonNullable<
  Awaited<ReturnType<typeof variantsList>>
>;
export type VariantsListQueryError = unknown;

export function useVariantsList<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof variantsList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof variantsList>>,
          TError,
          Awaited<ReturnType<typeof variantsList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVariantsList<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof variantsList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof variantsList>>,
          TError,
          Awaited<ReturnType<typeof variantsList>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVariantsList<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof variantsList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVariantsList<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof variantsList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVariantsListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getVariantsListSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof variantsList>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVariantsListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof variantsList>>> = ({
    signal,
  }) => variantsList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof variantsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VariantsListSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof variantsList>>
>;
export type VariantsListSuspenseQueryError = unknown;

export function useVariantsListSuspense<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof variantsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVariantsListSuspense<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof variantsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVariantsListSuspense<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof variantsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVariantsListSuspense<
  TData = Awaited<ReturnType<typeof variantsList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof variantsList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVariantsListSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const versionRetrieve = (signal?: AbortSignal) => {
  return customInstance<Version>({ url: `/version/`, method: "GET", signal });
};

export const getVersionRetrieveQueryKey = () => {
  return [`/version/`] as const;
};

export const getVersionRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof versionRetrieve>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionRetrieveQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof versionRetrieve>>> = ({
    signal,
  }) => versionRetrieve(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof versionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionRetrieve>>
>;
export type VersionRetrieveQueryError = unknown;

export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionRetrieve>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionRetrieveQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getVersionRetrieveSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof versionRetrieve>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionRetrieveQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof versionRetrieve>>> = ({
    signal,
  }) => versionRetrieve(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof versionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionRetrieveSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionRetrieve>>
>;
export type VersionRetrieveSuspenseQueryError = unknown;

export function useVersionRetrieveSuspense<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieveSuspense<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieveSuspense<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVersionRetrieveSuspense<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionRetrieveSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

export const getApiSchemaRetrieveResponseMock = ():
  | Blob
  | ApiSchemaRetrieve200Two
  | ApiSchemaRetrieve200Three
  | ApiSchemaRetrieve200Four =>
  faker.helpers.arrayElement([
    {
      [faker.string.alphanumeric(5)]: {},
    },
    {
      [faker.string.alphanumeric(5)]: {},
    },
    {
      [faker.string.alphanumeric(5)]: {},
    },
    {
      [faker.string.alphanumeric(5)]: {},
    },
  ]);

export const getApiTokenRefreshCreateResponseMock = (
  overrideResponse: Partial<TokenRefresh> = {}
): TokenRefresh => ({
  access: faker.string.alpha({ length: { min: 10, max: 20 } }),
  refresh: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getAuthLoginCreateResponseMock = (
  overrideResponse: Partial<Auth> = {}
): Auth => ({
  idToken: faker.string.alpha({ length: { min: 10, max: 20 } }),
  id: faker.number.int({ min: undefined, max: undefined }),
  email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  accessToken: faker.string.alpha({ length: { min: 10, max: 20 } }),
  refreshToken: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getDevicesListResponseMock = (): FCMDevice[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 255 } }),
        null,
      ]),
      undefined,
    ]),
    registrationId: faker.string.alpha({ length: { min: 10, max: 20 } }),
    deviceId: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 255 } }),
        null,
      ]),
      undefined,
    ]),
    active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
    dateCreated: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.date.past().toISOString().slice(0, 19) + "Z",
        null,
      ]),
      null,
    ]),
    type: faker.helpers.arrayElement(Object.values(TypeEnum)),
  }));

export const getDevicesCreateResponseMock = (
  overrideResponse: Partial<FCMDevice> = {}
): FCMDevice => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 255 } }),
      null,
    ]),
    undefined,
  ]),
  registrationId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  deviceId: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 255 } }),
      null,
    ]),
    undefined,
  ]),
  active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  dateCreated: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.date.past().toISOString().slice(0, 19) + "Z",
      null,
    ]),
    null,
  ]),
  type: faker.helpers.arrayElement(Object.values(TypeEnum)),
  ...overrideResponse,
});

export const getDevicesUpdateResponseMock = (
  overrideResponse: Partial<FCMDevice> = {}
): FCMDevice => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 255 } }),
      null,
    ]),
    undefined,
  ]),
  registrationId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  deviceId: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 255 } }),
      null,
    ]),
    undefined,
  ]),
  active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
  dateCreated: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.date.past().toISOString().slice(0, 19) + "Z",
      null,
    ]),
    null,
  ]),
  type: faker.helpers.arrayElement(Object.values(TypeEnum)),
  ...overrideResponse,
});

export const getGameCreateResponseMock = (
  overrideResponse: Partial<GameCreate> = {}
): GameCreate => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  variantId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  nationAssignment: faker.helpers.arrayElement(
    Object.values(NationAssignmentEnum)
  ),
  movementPhaseDuration: faker.helpers.arrayElement([
    faker.helpers.arrayElement(Object.values(MovementPhaseDurationEnum)),
    undefined,
  ]),
  retreatPhaseDuration: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(RetreatPhaseDurationEnum)),
      faker.helpers.arrayElement([] as const),
    ]),
    undefined,
  ]),
  private: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGameRetrieveResponseMock = (
  overrideResponse: Partial<GameRetrieve> = {}
): GameRetrieve => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  status: faker.string.alpha({ length: { min: 10, max: 20 } }),
  canJoin: faker.datatype.boolean(),
  canLeave: faker.datatype.boolean(),
  phases: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.number.int({ min: undefined, max: undefined })),
  currentPhaseId: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    null,
  ]),
  members: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    picture: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    nation: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    isCurrentUser: faker.datatype.boolean(),
    eliminated: faker.datatype.boolean(),
    kicked: faker.datatype.boolean(),
    isGameMaster: faker.datatype.boolean(),
  })),
  sandbox: faker.datatype.boolean(),
  victory: {
    ...{
      id: faker.number.int({ min: undefined, max: undefined }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      winningPhaseId: faker.number.int({ min: undefined, max: undefined }),
      members: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        id: faker.number.int({ min: undefined, max: undefined }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        picture: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        nation: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        isCurrentUser: faker.datatype.boolean(),
        eliminated: faker.datatype.boolean(),
        kicked: faker.datatype.boolean(),
        isGameMaster: faker.datatype.boolean(),
      })),
    },
  },
  variantId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  nationAssignment: faker.string.alpha({ length: { min: 10, max: 20 } }),
  phaseConfirmed: faker.datatype.boolean(),
  movementPhaseDuration: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  retreatPhaseDuration: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  private: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGameCloneToSandboxCreateResponseMock = (
  overrideResponse: Partial<GameCloneToSandbox> = {}
): GameCloneToSandbox => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGameConfirmPhaseUpdateResponseMock = (
  overrideResponse: Partial<PhaseState> = {}
): PhaseState => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ordersConfirmed: faker.datatype.boolean(),
  eliminated: faker.datatype.boolean(),
  orderableProvinces: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    type: faker.string.alpha({ length: { min: 10, max: 20 } }),
    supplyCenter: faker.datatype.boolean(),
    parentId: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    namedCoastIds: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
  })),
  member: {
    ...{
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      picture: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      nation: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      isCurrentUser: faker.datatype.boolean(),
      eliminated: faker.datatype.boolean(),
      kicked: faker.datatype.boolean(),
      isGameMaster: faker.datatype.boolean(),
    },
  },
  ...overrideResponse,
});

export const getGameConfirmPhasePartialUpdateResponseMock = (
  overrideResponse: Partial<PhaseState> = {}
): PhaseState => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ordersConfirmed: faker.datatype.boolean(),
  eliminated: faker.datatype.boolean(),
  orderableProvinces: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    type: faker.string.alpha({ length: { min: 10, max: 20 } }),
    supplyCenter: faker.datatype.boolean(),
    parentId: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    namedCoastIds: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
  })),
  member: {
    ...{
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      picture: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      nation: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      isCurrentUser: faker.datatype.boolean(),
      eliminated: faker.datatype.boolean(),
      kicked: faker.datatype.boolean(),
      isGameMaster: faker.datatype.boolean(),
    },
  },
  ...overrideResponse,
});

export const getGameJoinCreateResponseMock = (
  overrideResponse: Partial<Member> = {}
): Member => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  picture: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  nation: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  isCurrentUser: faker.datatype.boolean(),
  eliminated: faker.datatype.boolean(),
  kicked: faker.datatype.boolean(),
  isGameMaster: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGameOrdersCreateResponseMock = (
  overrideResponse: Partial<Order> = {}
): Order => ({
  source: {
    ...{
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    },
  },
  target: {
    ...{
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    },
  },
  aux: {
    ...{
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    },
  },
  namedCoast: {
    ...{
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    },
  },
  resolution: {
    ...{
      status: faker.string.alpha({ length: { min: 10, max: 20 } }),
      by: {
        ...{
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          type: faker.string.alpha({ length: { min: 10, max: 20 } }),
          supplyCenter: faker.datatype.boolean(),
          parentId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          namedCoastIds: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        },
      },
    },
  },
  options: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    value: faker.string.alpha({ length: { min: 10, max: 20 } }),
    label: faker.string.alpha({ length: { min: 10, max: 20 } }),
  })),
  orderType: faker.helpers.arrayElement(Object.values(OrderTypeEnum)),
  unitType: faker.helpers.arrayElement(Object.values(UnitTypeEnum)),
  nation: {
    ...{
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      color: faker.string.alpha({ length: { min: 10, max: 20 } }),
    },
  },
  complete: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
  step: faker.helpers.arrayElement([
    faker.helpers.arrayElement(Object.values(StepEnum)),
    faker.helpers.arrayElement([] as const),
  ]),
  title: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  summary: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  selected: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGameOrdersListResponseMock = (): Order[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    source: {
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        type: faker.string.alpha({ length: { min: 10, max: 20 } }),
        supplyCenter: faker.datatype.boolean(),
        parentId: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        namedCoastIds: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
    },
    target: {
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        type: faker.string.alpha({ length: { min: 10, max: 20 } }),
        supplyCenter: faker.datatype.boolean(),
        parentId: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        namedCoastIds: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
    },
    aux: {
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        type: faker.string.alpha({ length: { min: 10, max: 20 } }),
        supplyCenter: faker.datatype.boolean(),
        parentId: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        namedCoastIds: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
    },
    namedCoast: {
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        type: faker.string.alpha({ length: { min: 10, max: 20 } }),
        supplyCenter: faker.datatype.boolean(),
        parentId: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        namedCoastIds: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
    },
    resolution: {
      ...{
        status: faker.string.alpha({ length: { min: 10, max: 20 } }),
        by: {
          ...{
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            name: faker.string.alpha({ length: { min: 10, max: 20 } }),
            type: faker.string.alpha({ length: { min: 10, max: 20 } }),
            supplyCenter: faker.datatype.boolean(),
            parentId: faker.helpers.arrayElement([
              faker.helpers.arrayElement([
                faker.string.alpha({ length: { min: 10, max: 20 } }),
                null,
              ]),
              null,
            ]),
            namedCoastIds: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
          },
        },
      },
    },
    options: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      value: faker.string.alpha({ length: { min: 10, max: 20 } }),
      label: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    orderType: faker.helpers.arrayElement(Object.values(OrderTypeEnum)),
    unitType: faker.helpers.arrayElement(Object.values(UnitTypeEnum)),
    nation: {
      ...{
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        color: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    complete: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
    step: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(StepEnum)),
      faker.helpers.arrayElement([] as const),
    ]),
    title: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    summary: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    selected: faker.helpers.arrayElement([
      Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      undefined,
    ]),
  }));

export const getGamePhaseStatesListResponseMock = (): PhaseState[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    ordersConfirmed: faker.datatype.boolean(),
    eliminated: faker.datatype.boolean(),
    orderableProvinces: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    })),
    member: {
      ...{
        id: faker.number.int({ min: undefined, max: undefined }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        picture: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        nation: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        isCurrentUser: faker.datatype.boolean(),
        eliminated: faker.datatype.boolean(),
        kicked: faker.datatype.boolean(),
        isGameMaster: faker.datatype.boolean(),
      },
    },
  }));

export const getGamePhaseRetrieveResponseMock = (
  overrideResponse: Partial<PhaseRetrieve> = {}
): PhaseRetrieve => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  ordinal: faker.number.int({ min: undefined, max: undefined }),
  season: faker.string.alpha({ length: { min: 10, max: 20 } }),
  year: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  type: faker.string.alpha({ length: { min: 10, max: 20 } }),
  remainingTime: faker.number.int({ min: undefined, max: undefined }),
  scheduledResolution: faker.date.past().toISOString().slice(0, 19) + "Z",
  status: faker.helpers.arrayElement(Object.values(StatusEnum)),
  units: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    type: faker.string.alpha({ length: { min: 10, max: 20 } }),
    nation: {
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      color: faker.string.alpha({ length: { min: 10, max: 20 } }),
    },
    province: {
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    },
    dislodged: faker.datatype.boolean(),
    dislodgedBy: faker.helpers.arrayElement([
      faker.helpers.arrayElement([null]),
      null,
    ]),
  })),
  supplyCenters: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    province: {
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    },
    nation: {
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      color: faker.string.alpha({ length: { min: 10, max: 20 } }),
    },
  })),
  previousPhaseId: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    null,
  ]),
  nextPhaseId: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      null,
    ]),
    null,
  ]),
  ...overrideResponse,
});

export const getGamePhasesListResponseMock = (): PhaseList[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    ordinal: faker.number.int({ min: undefined, max: undefined }),
    season: faker.string.alpha({ length: { min: 10, max: 20 } }),
    year: faker.number.int({ min: undefined, max: undefined }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    type: faker.string.alpha({ length: { min: 10, max: 20 } }),
    status: faker.helpers.arrayElement(Object.values(StatusEnum)),
  }));

export const getGameResolvePhaseCreateResponseMock = (
  overrideResponse: Partial<PhaseList> = {}
): PhaseList => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  ordinal: faker.number.int({ min: undefined, max: undefined }),
  season: faker.string.alpha({ length: { min: 10, max: 20 } }),
  year: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  type: faker.string.alpha({ length: { min: 10, max: 20 } }),
  status: faker.helpers.arrayElement(Object.values(StatusEnum)),
  ...overrideResponse,
});

export const getGamesListResponseMock = (): GameList[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    status: faker.string.alpha({ length: { min: 10, max: 20 } }),
    canJoin: faker.datatype.boolean(),
    canLeave: faker.datatype.boolean(),
    variantId: faker.string.alpha({ length: { min: 10, max: 20 } }),
    phases: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.number.int({ min: undefined, max: undefined })),
    currentPhaseId: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        null,
      ]),
      null,
    ]),
    private: faker.datatype.boolean(),
    movementPhaseDuration: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    retreatPhaseDuration: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        null,
      ]),
      null,
    ]),
    nationAssignment: faker.string.alpha({ length: { min: 10, max: 20 } }),
    members: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      picture: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      nation: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      isCurrentUser: faker.datatype.boolean(),
      eliminated: faker.datatype.boolean(),
      kicked: faker.datatype.boolean(),
      isGameMaster: faker.datatype.boolean(),
    })),
    victory: {
      ...{
        id: faker.number.int({ min: undefined, max: undefined }),
        type: faker.string.alpha({ length: { min: 10, max: 20 } }),
        winningPhaseId: faker.number.int({ min: undefined, max: undefined }),
        members: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1
        ).map(() => ({
          id: faker.number.int({ min: undefined, max: undefined }),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          picture: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          nation: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          isCurrentUser: faker.datatype.boolean(),
          eliminated: faker.datatype.boolean(),
          kicked: faker.datatype.boolean(),
          isGameMaster: faker.datatype.boolean(),
        })),
      },
    },
    sandbox: faker.datatype.boolean(),
  }));

export const getGamesChannelsListResponseMock = (): Channel[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    private: faker.datatype.boolean(),
    messages: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      body: faker.string.alpha({ length: { min: 10, max: 1000 } }),
      sender: {
        ...{
          id: faker.number.int({ min: undefined, max: undefined }),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          picture: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          nation: {
            name: faker.string.alpha({ length: { min: 10, max: 20 } }),
            color: faker.string.alpha({ length: { min: 10, max: 20 } }),
          },
          isCurrentUser: faker.datatype.boolean(),
        },
      },
      createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    })),
    memberIds: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.number.int({ min: undefined, max: undefined })),
  }));

export const getGamesChannelsMessagesCreateCreateResponseMock = (
  overrideResponse: Partial<ChannelMessage> = {}
): ChannelMessage => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  body: faker.string.alpha({ length: { min: 10, max: 1000 } }),
  sender: {
    ...{
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      picture: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      nation: {
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        color: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
      isCurrentUser: faker.datatype.boolean(),
    },
  },
  createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
  ...overrideResponse,
});

export const getGamesChannelsCreateCreateResponseMock = (
  overrideResponse: Partial<Channel> = {}
): Channel => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  private: faker.datatype.boolean(),
  messages: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    body: faker.string.alpha({ length: { min: 10, max: 1000 } }),
    sender: {
      ...{
        id: faker.number.int({ min: undefined, max: undefined }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        picture: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        nation: {
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          color: faker.string.alpha({ length: { min: 10, max: 20 } }),
        },
        isCurrentUser: faker.datatype.boolean(),
      },
    },
    createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
  })),
  memberIds: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.number.int({ min: undefined, max: undefined })),
  ...overrideResponse,
});

export const getGamesDrawProposalsListResponseMock = (): DrawProposal[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    createdBy: {
      ...{
        id: faker.number.int({ min: undefined, max: undefined }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        picture: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        nation: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        isCurrentUser: faker.datatype.boolean(),
      },
    },
    status: faker.string.alpha({ length: { min: 10, max: 20 } }),
    combinedScCount: faker.number.int({ min: undefined, max: undefined }),
    victoryThreshold: faker.number.int({ min: undefined, max: undefined }),
    votes: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      member: {
        ...{
          id: faker.number.int({ min: undefined, max: undefined }),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          picture: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          nation: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          isCurrentUser: faker.datatype.boolean(),
        },
      },
      included: faker.datatype.boolean(),
      accepted: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
    })),
    phaseId: faker.number.int({ min: undefined, max: undefined }),
    createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
    includedMemberIds: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => faker.number.int({ min: undefined, max: undefined })),
  }));

export const getGamesDrawProposalsVoteUpdateResponseMock = (
  overrideResponse: Partial<DrawVoteUpdate> = {}
): DrawVoteUpdate => ({
  accepted: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGamesDrawProposalsVotePartialUpdateResponseMock = (
  overrideResponse: Partial<DrawVoteUpdate> = {}
): DrawVoteUpdate => ({
  accepted: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGamesDrawProposalsCreateCreateResponseMock = (
  overrideResponse: Partial<DrawProposal> = {}
): DrawProposal => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  createdBy: {
    ...{
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      picture: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      nation: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      isCurrentUser: faker.datatype.boolean(),
    },
  },
  status: faker.string.alpha({ length: { min: 10, max: 20 } }),
  combinedScCount: faker.number.int({ min: undefined, max: undefined }),
  victoryThreshold: faker.number.int({ min: undefined, max: undefined }),
  votes: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    member: {
      ...{
        id: faker.number.int({ min: undefined, max: undefined }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        picture: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        nation: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            faker.string.alpha({ length: { min: 10, max: 20 } }),
            null,
          ]),
          null,
        ]),
        isCurrentUser: faker.datatype.boolean(),
      },
    },
    included: faker.datatype.boolean(),
    accepted: faker.helpers.arrayElement([faker.datatype.boolean(), null]),
  })),
  phaseId: faker.number.int({ min: undefined, max: undefined }),
  createdAt: faker.date.past().toISOString().slice(0, 19) + "Z",
  includedMemberIds: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => faker.number.int({ min: undefined, max: undefined })),
  ...overrideResponse,
});

export const getSandboxGameCreateResponseMock = (
  overrideResponse: Partial<GameCreateSandbox> = {}
): GameCreateSandbox => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  name: faker.string.alpha({ length: { min: 10, max: 20 } }),
  variantId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getUserRetrieveResponseMock = (
  overrideResponse: Partial<UserProfile> = {}
): UserProfile => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 2, max: 255 } }),
  picture: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getUserUpdateUpdateResponseMock = (
  overrideResponse: Partial<UserProfile> = {}
): UserProfile => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 2, max: 255 } }),
  picture: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getUserUpdatePartialUpdateResponseMock = (
  overrideResponse: Partial<UserProfile> = {}
): UserProfile => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  name: faker.string.alpha({ length: { min: 2, max: 255 } }),
  picture: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      null,
    ]),
    null,
  ]),
  email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getVariantsListResponseMock = (): Variant[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1
  ).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    description: faker.string.alpha({ length: { min: 10, max: 20 } }),
    author: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
    soloVictoryScCount: faker.number.int({ min: undefined, max: undefined }),
    nations: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      color: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    provinces: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1
    ).map(() => ({
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      supplyCenter: faker.datatype.boolean(),
      parentId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          null,
        ]),
        null,
      ]),
      namedCoastIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    })),
    templatePhase: {
      id: faker.number.int({ min: undefined, max: undefined }),
      ordinal: faker.number.int({ min: undefined, max: undefined }),
      season: faker.string.alpha({ length: { min: 10, max: 20 } }),
      year: faker.number.int({ min: undefined, max: undefined }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      type: faker.string.alpha({ length: { min: 10, max: 20 } }),
      remainingTime: faker.number.int({ min: undefined, max: undefined }),
      scheduledResolution: faker.date.past().toISOString().slice(0, 19) + "Z",
      status: faker.helpers.arrayElement(Object.values(StatusEnum)),
      units: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        type: faker.string.alpha({ length: { min: 10, max: 20 } }),
        nation: {
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          color: faker.string.alpha({ length: { min: 10, max: 20 } }),
        },
        province: {
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          type: faker.string.alpha({ length: { min: 10, max: 20 } }),
          supplyCenter: faker.datatype.boolean(),
          parentId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          namedCoastIds: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        },
        dislodged: faker.datatype.boolean(),
        dislodgedBy: faker.helpers.arrayElement([
          faker.helpers.arrayElement([null]),
          null,
        ]),
      })),
      supplyCenters: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        province: {
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          type: faker.string.alpha({ length: { min: 10, max: 20 } }),
          supplyCenter: faker.datatype.boolean(),
          parentId: faker.helpers.arrayElement([
            faker.helpers.arrayElement([
              faker.string.alpha({ length: { min: 10, max: 20 } }),
              null,
            ]),
            null,
          ]),
          namedCoastIds: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        },
        nation: {
          name: faker.string.alpha({ length: { min: 10, max: 20 } }),
          color: faker.string.alpha({ length: { min: 10, max: 20 } }),
        },
      })),
      previousPhaseId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          null,
        ]),
        null,
      ]),
      nextPhaseId: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          null,
        ]),
        null,
      ]),
    },
  }));

export const getVersionRetrieveResponseMock = (
  overrideResponse: Partial<Version> = {}
): Version => ({
  environment: faker.string.alpha({ length: { min: 10, max: 20 } }),
  version: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getApiSchemaRetrieveMockHandler = (
  overrideResponse?:
    | Blob
    | ApiSchemaRetrieve200Two
    | ApiSchemaRetrieve200Three
    | ApiSchemaRetrieve200Four
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) =>
        | Promise<
            | Blob
            | ApiSchemaRetrieve200Two
            | ApiSchemaRetrieve200Three
            | ApiSchemaRetrieve200Four
          >
        | Blob
        | ApiSchemaRetrieve200Two
        | ApiSchemaRetrieve200Three
        | ApiSchemaRetrieve200Four),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/schema/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getApiSchemaRetrieveResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getApiTestSentryRetrieveMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<void> | void),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/test-sentry/",
    async info => {
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 200 });
    },
    options
  );
};

export const getApiTokenRefreshCreateMockHandler = (
  overrideResponse?:
    | TokenRefresh
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<TokenRefresh> | TokenRefresh),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/token/refresh/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getApiTokenRefreshCreateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getAuthLoginCreateMockHandler = (
  overrideResponse?:
    | Auth
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<Auth> | Auth),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/auth/login/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getAuthLoginCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getDevicesListMockHandler = (
  overrideResponse?:
    | FCMDevice[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<FCMDevice[]> | FCMDevice[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/devices/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getDevicesListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getDevicesCreateMockHandler = (
  overrideResponse?:
    | FCMDevice
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<FCMDevice> | FCMDevice),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/devices/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getDevicesCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getDevicesUpdateMockHandler = (
  overrideResponse?:
    | FCMDevice
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0]
      ) => Promise<FCMDevice> | FCMDevice),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/devices/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getDevicesUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameCreateMockHandler = (
  overrideResponse?:
    | GameCreate
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<GameCreate> | GameCreate),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/game/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameRetrieveMockHandler = (
  overrideResponse?:
    | GameRetrieve
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<GameRetrieve> | GameRetrieve),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/game/:gameId/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameRetrieveResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameCloneToSandboxCreateMockHandler = (
  overrideResponse?:
    | GameCloneToSandbox
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<GameCloneToSandbox> | GameCloneToSandbox),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/game/:gameId/clone-to-sandbox/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameCloneToSandboxCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameConfirmPhaseUpdateMockHandler = (
  overrideResponse?:
    | PhaseState
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0]
      ) => Promise<PhaseState> | PhaseState),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/game/:gameId/confirm-phase/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameConfirmPhaseUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameConfirmPhasePartialUpdateMockHandler = (
  overrideResponse?:
    | PhaseState
    | ((
        info: Parameters<Parameters<typeof http.patch>[1]>[0]
      ) => Promise<PhaseState> | PhaseState),
  options?: RequestHandlerOptions
) => {
  return http.patch(
    "*/game/:gameId/confirm-phase/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameConfirmPhasePartialUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameJoinCreateMockHandler = (
  overrideResponse?:
    | Member
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<Member> | Member),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/game/:gameId/join/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameJoinCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameLeaveDestroyMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0]
      ) => Promise<void> | void),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/game/:gameId/leave/",
    async info => {
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options
  );
};

export const getGameOrdersCreateMockHandler = (
  overrideResponse?:
    | Order
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<Order> | Order),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/game/:gameId/orders/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameOrdersCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameOrdersListMockHandler = (
  overrideResponse?:
    | Order[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<Order[]> | Order[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/game/:gameId/orders/:phaseId",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameOrdersListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameOrdersDeleteDestroyMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0]
      ) => Promise<void> | void),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/game/:gameId/orders/delete/:sourceId",
    async info => {
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options
  );
};

export const getGamePhaseStatesListMockHandler = (
  overrideResponse?:
    | PhaseState[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<PhaseState[]> | PhaseState[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/game/:gameId/phase-states/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamePhaseStatesListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamePhaseRetrieveMockHandler = (
  overrideResponse?:
    | PhaseRetrieve
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<PhaseRetrieve> | PhaseRetrieve),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/game/:gameId/phase/:phaseId/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamePhaseRetrieveResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamePhasesListMockHandler = (
  overrideResponse?:
    | PhaseList[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<PhaseList[]> | PhaseList[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/game/:gameId/phases/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamePhasesListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGameResolvePhaseCreateMockHandler = (
  overrideResponse?:
    | PhaseList
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<PhaseList> | PhaseList),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/game/:gameId/resolve-phase/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGameResolvePhaseCreateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesListMockHandler = (
  overrideResponse?:
    | GameList[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<GameList[]> | GameList[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/games/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesChannelsListMockHandler = (
  overrideResponse?:
    | Channel[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<Channel[]> | Channel[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/games/:gameId/channels/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesChannelsListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesChannelsMessagesCreateCreateMockHandler = (
  overrideResponse?:
    | ChannelMessage
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<ChannelMessage> | ChannelMessage),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/games/:gameId/channels/:channelId/messages/create/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesChannelsMessagesCreateCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesChannelsCreateCreateMockHandler = (
  overrideResponse?:
    | Channel
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<Channel> | Channel),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/games/:gameId/channels/create/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesChannelsCreateCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesDrawProposalsListMockHandler = (
  overrideResponse?:
    | DrawProposal[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<DrawProposal[]> | DrawProposal[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/games/:gameId/draw-proposals/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesDrawProposalsListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesDrawProposalsCancelDestroyMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0]
      ) => Promise<void> | void),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/games/:gameId/draw-proposals/:proposalId/cancel/",
    async info => {
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 204 });
    },
    options
  );
};

export const getGamesDrawProposalsVoteUpdateMockHandler = (
  overrideResponse?:
    | DrawVoteUpdate
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0]
      ) => Promise<DrawVoteUpdate> | DrawVoteUpdate),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/games/:gameId/draw-proposals/:proposalId/vote/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesDrawProposalsVoteUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesDrawProposalsVotePartialUpdateMockHandler = (
  overrideResponse?:
    | DrawVoteUpdate
    | ((
        info: Parameters<Parameters<typeof http.patch>[1]>[0]
      ) => Promise<DrawVoteUpdate> | DrawVoteUpdate),
  options?: RequestHandlerOptions
) => {
  return http.patch(
    "*/games/:gameId/draw-proposals/:proposalId/vote/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesDrawProposalsVotePartialUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getGamesDrawProposalsCreateCreateMockHandler = (
  overrideResponse?:
    | DrawProposal
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<DrawProposal> | DrawProposal),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/games/:gameId/draw-proposals/create/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getGamesDrawProposalsCreateCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getPhaseResolveCreateMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<void> | void),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/phase/resolve/",
    async info => {
      if (typeof overrideResponse === "function") {
        await overrideResponse(info);
      }
      return new HttpResponse(null, { status: 200 });
    },
    options
  );
};

export const getSandboxGameCreateMockHandler = (
  overrideResponse?:
    | GameCreateSandbox
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<GameCreateSandbox> | GameCreateSandbox),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/sandbox-game/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getSandboxGameCreateResponseMock()
        ),
        { status: 201, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getUserRetrieveMockHandler = (
  overrideResponse?:
    | UserProfile
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<UserProfile> | UserProfile),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/user/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getUserRetrieveResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getUserUpdateUpdateMockHandler = (
  overrideResponse?:
    | UserProfile
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0]
      ) => Promise<UserProfile> | UserProfile),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/user/update/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getUserUpdateUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getUserUpdatePartialUpdateMockHandler = (
  overrideResponse?:
    | UserProfile
    | ((
        info: Parameters<Parameters<typeof http.patch>[1]>[0]
      ) => Promise<UserProfile> | UserProfile),
  options?: RequestHandlerOptions
) => {
  return http.patch(
    "*/user/update/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getUserUpdatePartialUpdateResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getVariantsListMockHandler = (
  overrideResponse?:
    | Variant[]
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<Variant[]> | Variant[]),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/variants/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getVariantsListResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};

export const getVersionRetrieveMockHandler = (
  overrideResponse?:
    | Version
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<Version> | Version),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/version/",
    async info => {
      return new HttpResponse(
        JSON.stringify(
          overrideResponse !== undefined
            ? typeof overrideResponse === "function"
              ? await overrideResponse(info)
              : overrideResponse
            : getVersionRetrieveResponseMock()
        ),
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    },
    options
  );
};
export const getMock = () => [
  getApiSchemaRetrieveMockHandler(),
  getApiTestSentryRetrieveMockHandler(),
  getApiTokenRefreshCreateMockHandler(),
  getAuthLoginCreateMockHandler(),
  getDevicesListMockHandler(),
  getDevicesCreateMockHandler(),
  getDevicesUpdateMockHandler(),
  getGameCreateMockHandler(),
  getGameRetrieveMockHandler(),
  getGameCloneToSandboxCreateMockHandler(),
  getGameConfirmPhaseUpdateMockHandler(),
  getGameConfirmPhasePartialUpdateMockHandler(),
  getGameJoinCreateMockHandler(),
  getGameLeaveDestroyMockHandler(),
  getGameOrdersCreateMockHandler(),
  getGameOrdersListMockHandler(),
  getGameOrdersDeleteDestroyMockHandler(),
  getGamePhaseStatesListMockHandler(),
  getGamePhaseRetrieveMockHandler(),
  getGamePhasesListMockHandler(),
  getGameResolvePhaseCreateMockHandler(),
  getGamesListMockHandler(),
  getGamesChannelsListMockHandler(),
  getGamesChannelsMessagesCreateCreateMockHandler(),
  getGamesChannelsCreateCreateMockHandler(),
  getGamesDrawProposalsListMockHandler(),
  getGamesDrawProposalsCancelDestroyMockHandler(),
  getGamesDrawProposalsVoteUpdateMockHandler(),
  getGamesDrawProposalsVotePartialUpdateMockHandler(),
  getGamesDrawProposalsCreateCreateMockHandler(),
  getPhaseResolveCreateMockHandler(),
  getSandboxGameCreateMockHandler(),
  getUserRetrieveMockHandler(),
  getUserUpdateUpdateMockHandler(),
  getUserUpdatePartialUpdateMockHandler(),
  getVariantsListMockHandler(),
  getVersionRetrieveMockHandler(),
];
